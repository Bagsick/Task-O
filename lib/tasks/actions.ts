'use server'

import { createServerSupabaseClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { logActivity } from '@/lib/activities/actions'

export async function createTask(data: {
    title: string
    description?: string
    status: string
    priority?: string
    due_date?: string
    due_time?: string
    project_id: string
    team_id?: string
    assigned_to?: string
}) {
    const supabase = await createServerSupabaseClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) throw new Error('Unauthorized')

    // 1. Role-based validation
    const { data: member } = await supabase
        .from('project_members')
        .select('role')
        .eq('project_id', data.project_id)
        .eq('user_id', user.id)
        .single()

    const role = member?.role || 'viewer'
    if (role === 'viewer') throw new Error('Insufficient permissions to create tasks')

    // Tech Lead validation: can only assign within their teams
    if (role === 'tech_lead' && data.assigned_to) {
        const { data: leadTeams } = await supabase
            .from('team_members')
            .select('team_id')
            .eq('user_id', user.id)

        const leadTeamIds = leadTeams?.map(t => t.team_id) || []

        const { data: isTeamMember } = await supabase
            .from('team_members')
            .select('id')
            .eq('user_id', data.assigned_to)
            .in('team_id', leadTeamIds)
            .maybeSingle()

        if (!isTeamMember) throw new Error('Tech Leads can only assign tasks to their own team members')
    }

    // Member validation: can only assign to themselves
    if (role === 'member' && data.assigned_to && data.assigned_to !== user.id) {
        throw new Error('Members can only assign tasks to themselves')
    }

    const { data: task, error } = await supabase
        .from('tasks')
        .insert({
            ...data,
            created_by: user.id,
            updated_at: new Date().toISOString()
        })
        .select()
        .single()

    if (error) throw error

    // 2. Send Notification if assigned
    if (data.assigned_to) {
        await supabase.from('notifications').insert({
            user_id: data.assigned_to,
            type: 'task_assignment',
            message: `MISSION_ASSIGNED: ${data.title}`,
            related_id: task.id,
            read: false
        })
    }

    // 3. Log Activity
    await logActivity({
        projectId: data.project_id,
        taskId: task.id,
        type: 'task_created',
        message: `Created task: ${data.title}`
    })

    revalidatePath(`/projects/${data.project_id}`)
    revalidatePath(`/projects/${data.project_id}/tasks`)
    revalidatePath('/dashboard')

    return task
}

export async function updateTask(taskId: string, data: any) {
    const supabase = await createServerSupabaseClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) throw new Error('Unauthorized')

    // 1. Get original task and user role
    const { data: originalTask } = await supabase
        .from('tasks')
        .select('*, created_by, title, project_id, assigned_to, team_id')
        .eq('id', taskId)
        .single()

    if (!originalTask) throw new Error('Task not found')

    const { data: member } = await supabase
        .from('project_members')
        .select('role')
        .eq('project_id', originalTask.project_id)
        .eq('user_id', user.id)
        .single()

    const role = member?.role || 'viewer'

    // 2. Permission enforcement
    if (role === 'admin' || role === 'manager') {
        // Full access
    } else if (role === 'tech_lead') {
        // Must check if task belongs to one of their teams
        const { data: leadTeams } = await supabase
            .from('team_members')
            .select('team_id')
            .eq('user_id', user.id)

        const leadTeamIds = leadTeams?.map((t: any) => t.team_id) || []
        if (!leadTeamIds.includes(originalTask.team_id)) {
            throw new Error('Tech Leads can only edit tasks within their teams')
        }

        // If updating assignee, must be within their team
        if (data.assigned_to && data.assigned_to !== originalTask.assigned_to) {
            const { data: isTeamMember } = await supabase
                .from('team_members')
                .select('id')
                .eq('user_id', data.assigned_to)
                .in('team_id', leadTeamIds)
                .maybeSingle()

            if (!isTeamMember) throw new Error('Tech Leads can only assign within their teams')
        }
    } else if (role === 'member') {
        // Can only edit if assigned to them
        if (originalTask.assigned_to !== user.id) {
            throw new Error('Members can only edit tasks assigned to them')
        }
        // Cannot change assignee
        if (data.assigned_to && data.assigned_to !== user.id) {
            throw new Error('Members cannot reassign tasks to others')
        }
    } else {
        throw new Error('Insufficient permissions')
    }

    const { error } = await supabase
        .from('tasks')
        .update({
            ...data,
            updated_at: new Date().toISOString()
        })
        .eq('id', taskId)

    if (error) throw error

    // Notify creator if status changed
    if (data.status && data.status !== originalTask.status) {
        const statusLabel = data.status === 'in_progress' ? 'ACTIVE_DEPLOY' :
            data.status === 'review' ? 'PENDING_REVIEW' :
                data.status === 'completed' ? 'MISSION_COMPLETE' : 'PENDING'

        await supabase.from('notifications').insert({
            user_id: originalTask.created_by,
            type: 'task_status_change',
            message: `STATUS_ALERT: ${originalTask.title} is now ${statusLabel}`,
            related_id: taskId,
            read: false
        })

        // Log status change activity
        await logActivity({
            projectId: originalTask.project_id,
            taskId: taskId,
            type: 'status_change',
            message: `Changed status from ${originalTask.status} to ${data.status}`,
            metadata: { from: originalTask.status, to: data.status }
        })
    } else {
        // Log generic update
        await logActivity({
            projectId: originalTask.project_id,
            taskId: taskId,
            type: 'task_updated',
            message: `Updated task parameters`
        })
    }

    revalidatePath('/dashboard')
    revalidatePath(`/projects/${originalTask.project_id}/tasks`)
}

export async function deleteTask(taskId: string) {
    const supabase = await createServerSupabaseClient()
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) throw new Error('Unauthorized')

    // 1. Check permissions
    const { data: task } = await supabase
        .from('tasks')
        .select('project_id')
        .eq('id', taskId)
        .single()

    if (task) {
        const { data: member } = await supabase
            .from('project_members')
            .select('role')
            .eq('project_id', task.project_id)
            .eq('user_id', user.id)
            .single()

        if (member?.role !== 'admin' && member?.role !== 'manager') {
            throw new Error('Only Admins or Managers can delete tasks')
        }
    }

    const { error } = await supabase
        .from('tasks')
        .delete()
        .eq('id', taskId)

    if (error) throw error

    revalidatePath('/dashboard')
}
